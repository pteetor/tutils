% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Wrapper.R
\name{Wrapper}
\alias{Wrapper}
\alias{is.Wrapper}
\title{Wrap a value and optional messages}
\usage{
Wrapper(
  value,
  errors = list(),
  warnings = list(),
  info = list(),
  include = list(),
  ...
)

is.Wrapper(x)
}
\arguments{
\item{errors}{List of error messages (list, optional)}

\item{warnings}{List of warning messages (list, optional)}

\item{info}{List of informational messages (list, optional)}

\item{include}{A list of already-wrapped objects, who's
errors, warnings, and infos should be included in this wrapper}

\item{x}{A value to be wrapped}

\item{quiet}{If TRUE, print the enclosed messages, if any, before
extracting the enclosed value (logical)}
}
\value{
\code{Wrapper} and \code{wrap} eturn a list with class \code{Wrapper}.
\code{unwrap} returns the value wrapped inside the Wrapper container.
}
\description{
The \code{wrap} function wraps a value inside a \code{Wrapper} container,
possibly incorporating wrapped messages, too.
}
\details{
The \code{unwrap} function extracts the value from the container.
Unless \code{quiet = TRUE}, it will print the wrapped, associated messages, if any,
before returning that extracted value (so the message are not ignored).

As a convenience to the caller, the errors, warnings, and info
may be supplied as character vectors (or even NULL), but they will be coerced to lists
and stored as lists.
}
\examples{
w <- wrap(pi, error = "Help me!", warnings = "Just chillin'")

# Extract the wrapped value
unwrap(w)

# Extract the wrapped value and print the wrapped messages
unwrap(w, quiet = FALSE)

# Piggy back the error messages
wrap(pi, error = "Pi error", include = list( wrap("foo", error = "Foo error") ))

}
